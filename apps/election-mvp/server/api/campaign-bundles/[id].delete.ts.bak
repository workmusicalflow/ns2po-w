/**
 * API Route: DELETE /api/campaign-bundles/[id]
 * Supprime un campaign bundle existant
 */

import { getDatabase } from "../utils/database"

/**
 * V√©rifie les contraintes r√©f√©rentielles avant suppression d'un bundle
 * @param db - Instance de la base de donn√©es
 * @param bundleId - ID du bundle √† supprimer
 * @param bundleName - Nom du bundle pour les messages d'erreur
 * @throws CreateError si des r√©f√©rences existent
 */
async function checkReferentialConstraints(db: any, bundleId: string, bundleName: string) {
  const constraints = []

  // 1. V√©rifier si le bundle est r√©f√©renc√© dans des devis actifs
  const activeQuotes = await db.execute({
    sql: `SELECT id, customer_data, status
          FROM quotes
          WHERE status NOT IN ('cancelled', 'expired')
          AND (items LIKE ? OR items LIKE ?)`,
    args: [`%"bundleId":"${bundleId}"%`, `%"bundle_id":"${bundleId}"%`]
  })

  if (activeQuotes.rows.length > 0) {
    constraints.push({
      type: 'quotes',
      count: activeQuotes.rows.length,
      message: `${activeQuotes.rows.length} devis actif(s) utilisent ce bundle`
    })
  }

  // 2. V√©rifier si le bundle est r√©f√©renc√© dans des commandes
  const orders = await db.execute({
    sql: `SELECT id, customer_data, status
          FROM orders
          WHERE status NOT IN ('cancelled', 'refunded')
          AND (items LIKE ? OR items LIKE ?)`,
    args: [`%"bundleId":"${bundleId}"%`, `%"bundle_id":"${bundleId}"%`]
  })

  if (orders.rows.length > 0) {
    constraints.push({
      type: 'orders',
      count: orders.rows.length,
      message: `${orders.rows.length} commande(s) utilisent ce bundle`
    })
  }

  // 3. V√©rifier si le bundle est featured (important pour la vitrine)
  const featuredCheck = await db.execute({
    sql: 'SELECT display_order FROM campaign_bundles WHERE id = ? AND display_order <= 3',
    args: [bundleId]
  })

  if (featuredCheck.rows.length > 0) {
    constraints.push({
      type: 'featured',
      count: 1,
      message: 'Ce bundle est en vedette sur la page d\'accueil'
    })
  }

  // Si des contraintes existent, lever une erreur avec les d√©tails
  if (constraints.length > 0) {
    throw createError({
      statusCode: 409,
      statusMessage: 'Impossible de supprimer le bundle',
      data: {
        error: `Le bundle "${bundleName}" ne peut pas √™tre supprim√© car il est encore utilis√©`,
        constraints,
        alternatives: [
          'D√©sactiver le bundle au lieu de le supprimer',
          'Annuler d\'abord les devis et commandes associ√©s',
          'Retirer le bundle de la section vedette'
        ]
      }
    })
  }
}

export default defineEventHandler(async (event) => {
  const startTime = Date.now()

  try {
    const bundleId = getRouterParam(event, 'id')
    const query = getQuery(event)
    const force = query.force === 'true'
    const soft = query.soft === 'true'

    console.log(`üì¶ DELETE /api/campaign-bundles/${bundleId} - Suppression bundle (force: ${force}, soft: ${soft})`)

    if (!bundleId) {
      throw createError({
        statusCode: 400,
        statusMessage: 'ID du bundle requis'
      })
    }

    // Acc√®s √† la base de donn√©es
    const db = getDatabase()
    if (!db) {
      throw createError({
        statusCode: 500,
        statusMessage: 'Base de donn√©es non disponible'
      })
    }

    // V√©rifier que le bundle existe
    const existingBundle = await db.execute({
      sql: 'SELECT id, name FROM campaign_bundles WHERE id = ?',
      args: [bundleId]
    })

    if (existingBundle.rows.length === 0) {
      throw createError({
        statusCode: 404,
        statusMessage: 'Bundle non trouv√©'
      })
    }

    const bundleName = existingBundle.rows[0].name

    // V√©rifier les contraintes r√©f√©rentielles avant suppression (sauf si force=true)
    if (!force) {
      await checkReferentialConstraints(db, bundleId, bundleName)
    }

    try {
      if (soft) {
        // Soft delete: d√©sactiver le bundle au lieu de le supprimer
        await db.execute({
          sql: 'UPDATE campaign_bundles SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
          args: [bundleId]
        })

        console.log(`‚úÖ Bundle d√©sactiv√© avec succ√®s: ${bundleId} (${bundleName})`)

        const response = {
          success: true,
          message: `Bundle "${bundleName}" d√©sactiv√© avec succ√®s`,
          data: {
            id: bundleId,
            deactivatedAt: new Date().toISOString(),
            action: 'soft_delete'
          },
          duration: Date.now() - startTime
        }

        return response
      } else {
        // Hard delete: suppression d√©finitive
        // 1. Supprimer les produits du bundle (CASCADE automatique gr√¢ce aux FK)
        await db.execute({
          sql: 'DELETE FROM bundle_products WHERE bundle_id = ?',
          args: [bundleId]
        })

        // 2. Supprimer le bundle principal
        await db.execute({
          sql: 'DELETE FROM campaign_bundles WHERE id = ?',
          args: [bundleId]
        })

        console.log(`‚úÖ Bundle supprim√© avec succ√®s: ${bundleId} (${bundleName})`)

        const response = {
          success: true,
          message: `Bundle "${bundleName}" supprim√© d√©finitivement`,
          data: {
            id: bundleId,
            deletedAt: new Date().toISOString(),
            action: 'hard_delete',
            forced: force
          },
          duration: Date.now() - startTime
        }

        return response
      }

    } catch (dbError) {
      console.error('‚ùå Erreur base de donn√©es:', dbError)
      throw createError({
        statusCode: 500,
        statusMessage: 'Erreur lors de la suppression du bundle',
        data: { error: dbError.message }
      })
    }

  } catch (error) {
    console.error(`‚ùå Erreur DELETE /api/campaign-bundles/${getRouterParam(event, 'id')}:`, error)

    if (error.statusCode) {
      throw error
    }

    throw createError({
      statusCode: 500,
      statusMessage: 'Erreur interne du serveur',
      data: {
        error: error instanceof Error ? error.message : "Erreur inconnue",
        duration: Date.now() - startTime
      }
    })
  }
})