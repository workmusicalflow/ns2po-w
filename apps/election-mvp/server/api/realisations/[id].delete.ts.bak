/**
 * API Route: DELETE /api/realisations/[id]
 * Supprime une r√©alisation existante de la base Turso
 */

import { getDatabase } from "../utils/database"

export default defineEventHandler(async (event) => {
  const startTime = Date.now()

  try {
    const realisationId = getRouterParam(event, 'id')
    console.log(`üé® DELETE /api/realisations/${realisationId} - Suppression r√©alisation`)

    if (!realisationId) {
      throw createError({
        statusCode: 400,
        statusMessage: 'ID de la r√©alisation requis'
      })
    }

    // Acc√®s √† la base de donn√©es
    const db = getDatabase()
    if (!db) {
      throw createError({
        statusCode: 500,
        statusMessage: 'Base de donn√©es non disponible'
      })
    }

    // V√©rifier que la r√©alisation existe
    const existingRealisation = await db.execute({
      sql: 'SELECT id, title, source FROM realisations WHERE id = ?',
      args: [realisationId]
    })

    if (existingRealisation.rows.length === 0) {
      throw createError({
        statusCode: 404,
        statusMessage: 'R√©alisation non trouv√©e'
      })
    }

    const realisationTitle = existingRealisation.rows[0].title
    const realisationSource = existingRealisation.rows[0].source

    try {
      // V√©rification sp√©ciale pour les r√©alisations auto-discovery
      if (realisationSource === 'cloudinary-auto-discovery') {
        // Marquer comme supprim√©e plut√¥t que supprimer physiquement
        // pour √©viter qu'elle soit re-d√©couverte lors du prochain scan
        await db.execute({
          sql: 'UPDATE realisations SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
          args: [realisationId]
        })

        console.log(`‚úÖ R√©alisation auto-discovery d√©sactiv√©e: ${realisationId} (${realisationTitle})`)

        const response = {
          success: true,
          message: `R√©alisation "${realisationTitle}" d√©sactiv√©e avec succ√®s (source: auto-discovery)`,
          data: {
            id: realisationId,
            action: 'deactivated',
            reason: 'auto-discovery-source',
            deactivatedAt: new Date().toISOString()
          },
          source: 'turso',
          duration: Date.now() - startTime
        }

        return response
      }

      // Pour les autres sources, suppression physique
      await db.execute({
        sql: 'DELETE FROM realisations WHERE id = ?',
        args: [realisationId]
      })

      console.log(`‚úÖ R√©alisation supprim√©e avec succ√®s: ${realisationId} (${realisationTitle})`)

      const response = {
        success: true,
        message: `R√©alisation "${realisationTitle}" supprim√©e avec succ√®s`,
        data: {
          id: realisationId,
          action: 'deleted',
          deletedAt: new Date().toISOString()
        },
        source: 'turso',
        duration: Date.now() - startTime
      }

      // Cache headers
      setHeader(event, "Cache-Control", "no-cache")

      return response

    } catch (dbError) {
      console.error('‚ùå Erreur base de donn√©es:', dbError)

      // Si c'est une erreur de contrainte, la renvoyer telle quelle
      if (dbError.statusCode) {
        throw dbError
      }

      throw createError({
        statusCode: 500,
        statusMessage: 'Erreur lors de la suppression de la r√©alisation',
        data: { error: dbError.message }
      })
    }

  } catch (error) {
    console.error(`‚ùå Erreur DELETE /api/realisations/${getRouterParam(event, 'id')}:`, error)

    if (error.statusCode) {
      throw error
    }

    throw createError({
      statusCode: 500,
      statusMessage: 'Erreur interne du serveur',
      data: {
        error: error instanceof Error ? error.message : "Erreur inconnue",
        duration: Date.now() - startTime
      }
    })
  }
})